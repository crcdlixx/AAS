"""
多模型博弈系统 - 使用 LangGraph 实现
两个模型相互审查和改进答案，直到达成一致
"""
import os
from typing import TypedDict, Annotated
from dotenv import load_dotenv
from langgraph.graph import StateGraph, END
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage

# 加载环境变量
load_dotenv()


class DebateState(TypedDict):
    """博弈状态"""
    question: str  # 原始问题
    model1_answer: str  # 模型1的答案
    model2_review: str  # 模型2的审查意见
    iteration: int  # 当前迭代次数
    max_iterations: int  # 最大迭代次数
    consensus_reached: bool  # 是否达成共识
    final_answer: str  # 最终答案


def initialize_models():
    """初始化两个不同代理地址的 OpenAI 格式模型"""
    # 模型1配置
    model1 = ChatOpenAI(
        model=os.getenv("MODEL1_NAME", "gpt-4o-mini"),
        temperature=0.7,
        api_key=os.getenv("MODEL1_API_KEY"),
        base_url=os.getenv("MODEL1_BASE_URL", "https://api.openai.com/v1")
    )
    
    # 模型2配置
    model2 = ChatOpenAI(
        model=os.getenv("MODEL2_NAME", "gpt-4o"),
        temperature=0.7,
        api_key=os.getenv("MODEL2_API_KEY"),
        base_url=os.getenv("MODEL2_BASE_URL", "https://api.openai.com/v1")
    )
    
    print(f"模型1: {os.getenv('MODEL1_NAME', 'gpt-4o-mini')} @ {os.getenv('MODEL1_BASE_URL', 'https://api.openai.com/v1')}")
    print(f"模型2: {os.getenv('MODEL2_NAME', 'gpt-4o')} @ {os.getenv('MODEL2_BASE_URL', 'https://api.openai.com/v1')}")
    
    return model1, model2


# 初始化模型
model1, model2 = initialize_models()


def model1_propose(state: DebateState) -> DebateState:
    """模型1提出答案或根据审查意见改进答案"""
    question = state["question"]
    iteration = state["iteration"]
    
    if iteration == 0:
        # 第一次回答
        prompt = f"请回答以下问题：{question}"
        messages = [HumanMessage(content=prompt)]
    else:
        # 根据模型2的审查意见改进答案
        previous_answer = state["model1_answer"]
        review = state["model2_review"]
        prompt = f"""
原始问题：{question}

你之前的答案：
{previous_answer}

审查意见：
{review}

请根据审查意见改进你的答案。如果你认为审查意见合理，请修改答案；如果你认为原答案已经很好，请说明理由并保持或微调答案。
"""
        messages = [HumanMessage(content=prompt)]
    
    response = model1.invoke(messages)
    state["model1_answer"] = response.content
    
    print(f"\n{'='*60}")
    print(f"迭代 {iteration + 1} - 模型1的答案：")
    print(f"{'='*60}")
    print(response.content)
    
    return state


def model2_review(state: DebateState) -> DebateState:
    """模型2审查模型1的答案"""
    question = state["question"]
    answer = state["model1_answer"]
    
    prompt = f"""
原始问题：{question}

待审查的答案：
{answer}

请仔细审查这个答案，评估其：
1. 准确性
2. 完整性
3. 逻辑性
4. 是否有遗漏或错误

如果答案已经很好，请回复"APPROVED: [简短说明为什么这个答案很好]"
如果需要改进，请提供具体的改进建议。
"""
    
    messages = [HumanMessage(content=prompt)]
    response = model2.invoke(messages)
    state["model2_review"] = response.content
    
    print(f"\n{'-'*60}")
    print(f"模型2的审查意见：")
    print(f"{'-'*60}")
    print(response.content)
    
    # 检查是否达成共识
    if "APPROVED" in response.content.upper():
        state["consensus_reached"] = True
        state["final_answer"] = answer
    
    state["iteration"] += 1
    
    return state


def check_should_continue(state: DebateState) -> str:
    """检查是否应该继续迭代"""
    if state["consensus_reached"]:
        return "end"
    if state["iteration"] >= state["max_iterations"]:
        # 达到最大迭代次数，使用最后一次答案
        state["final_answer"] = state["model1_answer"]
        return "end"
    return "continue"


def create_debate_graph():
    """创建博弈图"""
    workflow = StateGraph(DebateState)
    
    # 添加节点
    workflow.add_node("model1_propose", model1_propose)
    workflow.add_node("model2_review", model2_review)
    
    # 设置入口点
    workflow.set_entry_point("model1_propose")
    
    # 添加边
    workflow.add_edge("model1_propose", "model2_review")
    
    # 添加条件边
    workflow.add_conditional_edges(
        "model2_review",
        check_should_continue,
        {
            "continue": "model1_propose",
            "end": END
        }
    )
    
    return workflow.compile()


def run_debate(question: str, max_iterations: int = 3):
    """运行博弈过程"""
    print(f"\n{'='*60}")
    print(f"开始多模型博弈")
    print(f"{'='*60}")
    print(f"问题：{question}")
    print(f"最大迭代次数：{max_iterations}")
    
    # 创建初始状态
    initial_state = {
        "question": question,
        "model1_answer": "",
        "model2_review": "",
        "iteration": 0,
        "max_iterations": max_iterations,
        "consensus_reached": False,
        "final_answer": ""
    }
    
    # 创建并运行图
    app = create_debate_graph()
    final_state = app.invoke(initial_state)
    
    # 输出最终结果
    print(f"\n{'='*60}")
    print(f"博弈结束")
    print(f"{'='*60}")
    print(f"总迭代次数：{final_state['iteration']}")
    print(f"是否达成共识：{'是' if final_state['consensus_reached'] else '否（达到最大迭代次数）'}")
    print(f"\n最终答案：")
    print(f"{'-'*60}")
    print(final_state['final_answer'])
    
    return final_state


if __name__ == "__main__":
    # 示例问题
    question = "什么是量子计算？请用简单的语言解释其基本原理和潜在应用。"
    
    # 运行博弈
    result = run_debate(question, max_iterations=3)
